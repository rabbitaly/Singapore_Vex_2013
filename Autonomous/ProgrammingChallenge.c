#pragma config(Sensor, in1,    firstTierLeft,  sensorPotentiometer)
#pragma config(Sensor, in2,    secondTier,     sensorPotentiometer)
#pragma config(Sensor, in3,    leftLight,      sensorLineFollower)
#pragma config(Sensor, in4,    rightLight,     sensorLineFollower)
#pragma config(Sensor, in5,    backLight,      sensorLineFollower)
#pragma config(Sensor, dgtl3,  led,            sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  backRight,      sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  backLeft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl10, bumperRight,    sensorTouch)
#pragma config(Sensor, dgtl11, bumperLeft,     sensorTouch)
#pragma config(Motor,  port1,           leftBack,      tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port2,           leftMiddle,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port4,           firstTierLeft, tmotorVex393, openLoop)
#pragma config(Motor,  port5,           secondTier,    tmotorVex393, openLoop)
#pragma config(Motor,  port6,           intakeRollers, tmotorVex269, openLoop)
#pragma config(Motor,  port7,           firstTierRight, tmotorVex393, openLoop)
#pragma config(Motor,  port8,           rightFront,    tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port9,           rightMiddle,   tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port10,          rightBack,     tmotorVex393HighSpeed, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "FnLibSingaporeVex2013.h"
int intake = 0;
task intakeStart()
{
	while (true)
	{
		if (intake == 1)
		{
			motor[intakeRollers] = -127;
		}
		else if (intake == -1)
		{
			motor[intakeRollers] = 127;
		}
		else
		{
			motor[intakeRollers] = 0;
		}
	}
}

/*
int armPos = 0;
int armPower = 0;
int adjuster;
float err;
task armcontrol()
{
int errors;
int olderror;
int adjust;
while(true)
{
errors = armPos - SensorValue(firstTierLeft);
int adjust = errors*0.45+olderror*0.9;
if(adjust>3)
{
motor[firstTierRight]=adjust+100;
motor[firstTierLeft]=adjust+100;
}
else if(adjust<-3)
{
motor[firstTierLeft]=adjust-100;
motor[firstTierRight]=adjust-100;
}
else{
motor[firstTierLeft]=-1;
motor[firstTierRight]=-1;
}
}
}
*/

task main()
{
	while(SensorValue[bumperLeft] == 0)
	{
	}
	StartTask(intakeStart);
	//StartTask(armcontrol);
	//armPos = 1000;
	ClearTimer(T4);
	moveSecondTierUp(127,450);
	moveSecondTierDown(127,50);
	intake = 1;
	motor[secondTier]=-127;
	wait10Msec(50);
	motor[secondTier]=0;
	moveStraightDistance(127,200);
	stopPid(0.6,0.3);
	wait10Msec(10);
	moveStraightDistance(30, 200);
	stopPid(0.6,0.3);
	wait10Msec(150);
	intake = 0;
	turnRight(127,650);
	intake = 1;
	moveFirstTierUp(127,400);
	motor[firstTierLeft]=20;
	motor[firstTierRight]=20;
	while (SensorValue[leftLight] > 1800)
	{
		moveStraight(127);
	}
	stopDrive();
	stopLift();
	intake = 0;
	while (SensorValue[bumperLeft] == 0)
	{
	}
	moveStraightDistance(127,350);
	stopPid(0.6,0.3);
	alignFoward(127);
	moveStraightDistance(127,100);
	stopPid(0.6,0.3);
	wait10Msec(10);
	turnRight(127,380);
	moveStraightDistance(127,1400);
	stopPid(0.6,0.3);
	moveFirstTierUp(127,1100);
	motor[firstTierLeft] = 20;
	motor[firstTierRight] = 20;
	moveStraightDistance(50,350);
	intake = -1;
	wait10Msec(300);
	intake = 0;
	moveStraightDistance(-50,250);
	stopPid(0.6,0.3);
	moveFirstTierDown(127,50);
	turnRight(127,760);
	moveStraightDistance(127,1800);
	stopPid(0.6,0.3);
	turnLeft(127,380);
	moveStraightDistance(127,500);
	stopPid(0.6,0.3);
	while(SensorValue[bumperLeft] == 0)
	{
	}
}
