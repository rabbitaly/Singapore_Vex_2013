#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    firstTierLeft,  sensorPotentiometer)
#pragma config(Sensor, in2,    secondTier,     sensorPotentiometer)
#pragma config(Sensor, in3,    leftLight,      sensorLineFollower)
#pragma config(Sensor, in4,    rightLight,     sensorLineFollower)
#pragma config(Sensor, in5,    backLight,      sensorLineFollower)
#pragma config(Sensor, I2C_1,  leftBack,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightBack,      sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftBack,      tmotorVex393HighSpeed, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port2,           leftMiddle,    tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port3,           leftFront,     tmotorVex393HighSpeed, openLoop)
#pragma config(Motor,  port4,           firstTierLeft, tmotorVex393, openLoop)
#pragma config(Motor,  port5,           secondTier,    tmotorVex393, openLoop)
#pragma config(Motor,  port6,           intakeRollers, tmotorVex269, openLoop)
#pragma config(Motor,  port7,           firstTierRight, tmotorVex393, openLoop)
#pragma config(Motor,  port8,           rightFront,    tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port9,           rightMiddle,   tmotorVex393HighSpeed, openLoop, reversed)
#pragma config(Motor,  port10,          rightBack,     tmotorVex393HighSpeed, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int cubicMap(int x)
{
	return ((((x*3)/25)*((x*3)/25)*((x*3)/25)/27 + x/2)*2)/3;
}

task main()
{
	while (true)
	{
		// Setting controller override
		// Default - two controller
		/* bool override = false;
		if (vexRT[Btn7U] == 1 && vexRT[Btn8U] == 1)
		{
		override = !override;
		}
		*/

		// Two controllers
		// if (override == false) // Button to override
		if (nVexRCReceiveState & vrXmit2)
		{
			{

				/* Drive */
				motor[leftBack] = cubicMap(vexRT[Ch2]+ vexRT[Ch4]);
				motor[leftMiddle] = cubicMap(vexRT[Ch2]+ vexRT[Ch4]);
				motor[leftFront] = cubicMap(vexRT[Ch2]+ vexRT[Ch4]);
				motor[rightBack] = cubicMap(vexRT[Ch2]- vexRT[Ch4]);
				motor[rightMiddle] = cubicMap(vexRT[Ch2]- vexRT[Ch4]);
				motor[rightFront] = cubicMap(vexRT[Ch2]- vexRT[Ch4]);

				/* Intake and Lift [Controller 2] */
				// First Tier
				motor[firstTierLeft] = vexRT[Ch2Xmtr2];
				motor[firstTierRight] = vexRT[Ch2Xmtr2];

				// Second Tier
				motor[secondTier] = vexRT[Ch3Xmtr2];

				/* Intake Rollers [Controller 2] */
				// Intake push out
				if (vexRT[Btn6UXmtr2] == 1)
				{
					motor[intakeRollers] = -127;
				}
				// Intake suck in
				else if (vexRT[Btn5UXmtr2] == 1)
				{
					motor[intakeRollers] = 127;
				}
				// Unpressed
				else
				{
					motor[intakeRollers] = 0;
				}
			}
		}
		// One controller
		else
		{

			/* Drive */
			motor[leftBack] = cubicMap(vexRT[Ch2]+ vexRT[Ch4]);
			motor[leftMiddle] = cubicMap(vexRT[Ch2]+ vexRT[Ch4]);
			motor[leftFront] = cubicMap(vexRT[Ch2]+ vexRT[Ch4]);
			motor[rightBack] = cubicMap(vexRT[Ch2]- vexRT[Ch4]);
			motor[rightMiddle] = cubicMap(vexRT[Ch2]- vexRT[Ch4]);
			motor[rightFront] = cubicMap(vexRT[Ch2]- vexRT[Ch4]);

			/* First Tier */
			if (vexRT[Btn6U] == 1)
			{
				motor[firstTierLeft] = 127;
				motor[firstTierRight] = 127;
			}
			else if (vexRT[Btn6D] == 1)
			{
				motor[firstTierLeft] = -127;
				motor[firstTierRight] = -127;
			}
			else
			{
				motor[firstTierLeft] = 0;
				motor[firstTierRight] = 0;
			}

			/* Second Tier */
			if (vexRT[Btn5U] == 1)
			{
				motor[secondTier] = 127;
			}
			else if (vexRT[Btn5D] == 1)
			{
				motor[secondTier] = -127;
			}
			else
			{
				motor[secondTier] = 0;
			}

			/* Intake */
			if (vexRT[Btn8R] == 1)
			{
				motor[intakeRollers] = 127;
			}
			else if (vexRT[Btn8D] == 1)
			{
				motor[intakeRollers] = -127;
			}
			else
			{
				motor[intakeRollers] = 0;
			}
		}
	}
}
